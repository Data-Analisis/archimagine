<archimate:Folder
    xmlns:archimate="http://www.archimatetool.com/archimate"
    name="Node.js, ECMAScript 2015/2016/2017, and beyond"
    id="95e08a8a-2461-4fe5-a39a-de6c8f48b39d"
    documentation="In 2015, the ECMAScript committee released a long-awaited major update of the JavaScript language. The update brought in many new features to JavaScript, such as Promises, arrow functions, and Class objects. The language update set the stage for improvements. since that should dramatically improve our ability to write clean, understandable JavaScript code.&#xA;The browser makers are adding those much-needed features, meaning the V8 engine is adding those features as well. These features are making their way into Node.js starting with version 4.x.&#xA;To learn about the current status of ES-2015 in Node.js, visit https://nodejs.org/en/docs/es6/.&#xA;By default, only the ES-2015/2016/2017 features that V8 considers stable are enabled by Node.js. Further features can be enabled with command-line options. The almost- complete features are enabled with the --es_staging option. The website documentation gives more information.&#xA;The Node green website (http:/​/​node.​green/​) has a table listing the status of a long list of features in Node.js versions.&#xA;The ES2017 language spec is published at: https:/​/​www.​ecma-​international.​org/​publications/​standards/​Ecma-​262.​htm.&#xA;The TC-39 committee does its work on GitHub https:/​/​github.​com/​tc39.&#xA;The ES-2015 features make a big improvement in the JavaScript language. One feature, the Promise class, should mean a fundamental rethinking of common idioms in Node.js programming. In ES-2017, a pair of new keywords, async and await, will simplify writing asynchronous code in Node.js, and it should encourage the Node.js community to further rethink the common idioms of the platform.&#xA;There's a long list of new JavaScript features, but let's quickly go over two of them that we'll use extensively.&#xA;The first is a lighter-weight function syntax called the arrow function:&#xA;   fs.readFile('file.txt', 'utf8', (err, data) => {&#xA;     if (err) ...; // do something with the error&#xA;     else ...;  // do something with the data&#xA;});&#xA;This is more than the syntactic sugar of replacing the function keyword with the fat arrow. Arrow functions are lighter-weight as well as being easier to read. The lighter weight comes at the cost of changing the value of this inside the arrow function. In regular functions, this has a unique value inside the function. In an arrow function, this has the same value as the scope containing the arrow function. This means that, when using an arrow function, we don't have to jump through hoops to bring this into the callback function because this is the same at both levels of the code.&#xA;The next feature is the Promise class, which is used for deferred and asynchronous computations. Deferred code execution to implement asynchronous behavior is a key paradigm for Node.js, and it requires two idiomatic conventions:&#xA;The last argument to an asynchronous function is a callback function, which is called when an asynchronous execution is to be performed&#xA;The first argument to the callback function is an error indicator&#xA;While convenient, these conventions resulted in multilayer code pyramids that can be difficult to understand and maintain:&#xA;   doThis(arg1, arg2, (err, result1, result2) => {&#xA;       if (err) ...;&#xA;       else {&#xA;            // do some work&#xA;doThat(arg2, arg3, (err2, results) => {&#xA;     if (err2) ...;&#xA;                 else {&#xA;                        doSomethingElse(arg5, err => {&#xA;                                if (err) .. ;&#xA;                                else ..;&#xA;}); }&#xA;Depending on how many steps are required for a specific task, a code pyramid can get quite deep. Promises will let us unravel the code pyramid and improve reliability, because error handling is more straightforward and easily captures all errors.&#xA;A Promise class is created as follows:&#xA;   function doThis(arg1, arg2) {&#xA;       return new Promise((resolve, reject) => {&#xA;           // execute some asynchronous code&#xA;           if (errorIsDetected) return reject(errorObject);&#xA;           // When the process is finished call this:&#xA;           resolve(result1, result2);&#xA;}); }&#xA;Rather than passing in a callback function, the caller receives a Promise object. When properly utilized, the preceding pyramid can be coded as follows:&#xA;   doThis(arg1, arg2)&#xA;   .then(result => {&#xA;     // This can receive only one value, hence to&#xA;     // receive multiple values requires an object or array&#xA;     return doThat(arg2, arg3);&#xA;   })&#xA;   .then((results) => {&#xA;     return doSomethingElse(arg5);&#xA;   })&#xA;   .then(() => {&#xA;      // do a final something&#xA;   })&#xA;   .catch(err => {&#xA;      // errors land here&#xA;   });&#xA;This works because the Promise class supports chaining if a then function returns a Promise object.&#xA;The async/await feature implements the promise of the Promise class to simplify asynchronous coding. This feature becomes active within an async function:&#xA;   async function mumble() {&#xA;      // async magic happens here&#xA;}&#xA;An async arrow function is as follows:&#xA;   const mumble = async () => {&#xA;       // async magic happens here&#xA;};&#xA;It's used as so:&#xA;   async function doSomething(arg1, arg2, arg3, arg4, arg5) {&#xA;       var { result1, result2 } = await doThis(arg1, arg2);&#xA;       var results = await doThat(arg2, arg3);&#xA;       await doSomethingElse(arg5);&#xA;       // do a final something&#xA;       return finalResult;&#xA;   }&#xA;Isn't this a breath of fresh air compared to the nested structure we started with?&#xA;The await keyword is used with a Promise. It automatically waits for the Promise to resolve. If the Promise resolves successfully then the value is returned, and if it resolves with an error then that error is thrown. Both handling results and throwing errors are handled in the natural manner.&#xA;This example also shows another ES2015 feature: destructuring. The fields of an object can be extracted using the following:&#xA;   var { value1, value2 } = {&#xA;       value1: &quot;Value 1&quot;, value2: &quot;Value 2&quot;, value3: &quot;Value3&quot;&#xA;};&#xA;We have an object with three fields, but extract only two of the fields."/>

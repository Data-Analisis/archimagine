<archimate:Folder
    xmlns:archimate="http://www.archimatetool.com/archimate"
    name="Running a simple script with Node.js"
    id="8ed21257-50d2-4049-91e7-da178a9b46b3"
    documentation="Now, let's see how to run scripts with Node.js. It's quite simple; let's start by referring to the help message shown previously. The command-line pattern is just a script filename and some script arguments, which should be familiar to anyone who has written scripts in other languages.&#xA;Creating and editing Node.js scripts can be done with any text editor that deals with plain text files, such as VI/VIM, Emacs, Notepad++, Atom, Visual Studio Code, Jedit, BB Edit, TextMate, or Komodo. It's helpful if it's a programmer-oriented editor, if only for the syntax coloring.&#xA;For this and other examples in this book, it doesn't truly matter where you put the files. However, for the sake of neatness, you can start by making a directory named node-web-dev in the home directory of your computer, and inside that creating one directory per chapter (for example, chap02 and chap03).&#xA;First, create a text file named ls.js with the following content:&#xA;   const fs = require('fs');&#xA;   const util = require('util');&#xA;   const fs_readdir = util.promisify(fs.readdir);&#xA;   (async () => {&#xA;     const files = await fs_readdir('.');&#xA;     for (let fn of files) {&#xA;       console.log(fn);&#xA;     }&#xA;   })().catch(err => { console.error(err); });&#xA;Next, run it by typing the following command:&#xA;   $ node ls.js&#xA;   ls.js&#xA;This is a pale cheap imitation of the Unix ls command (as if you couldn't figure that out from the name). The readdir function is a close analog to the Unix readdir system call (type man 3 readdir in a Terminal window to learn more) and is used to list the files in a directory.&#xA;We have written this using an inline async function, the await keyword, and an ES2015 for..of loop. Using util.promisify, we can convert any callback-oriented function so it returns a Promise, so that the Promise plays well with the await keyword.&#xA;By default fs module functions use the callback paradigm, as does most Node.js modules. But within async functions it is more convenient if functions instead return promises. Using util.promisify we can make it so.&#xA;This script is hardcoded to list files in the current directory. The real ls command takes a directory name, so let's modify the script a little.&#xA;Command-line arguments land in a global array named process.argv. Therefore we can modify ls.js, copying it as ls2.js, as follows to see how this array works:&#xA;   const fs = require('fs');&#xA;   const util = require('util');&#xA;   const fs_readdir = util.promisify(fs.readdir);&#xA;   (async () => {&#xA;     var dir = '.';&#xA;     if (process.argv[2]) dir = process.argv[2];&#xA;     const files = await fs_readdir(dir);&#xA;     for (let fn of files) {&#xA;       console.log(fn);&#xA;     }&#xA;   })().catch(err => { console.error(err); });&#xA;You can run it as follows:&#xA;   $ pwd&#xA;   /Users/David/chap02&#xA;   $ node ls2 ..&#xA;   chap01&#xA;   chap02&#xA;   $ node ls2&#xA;   app.js&#xA;   ls.js&#xA;   ls2.js&#xA;We simply checked if a command-line argument was present, if (process.argv[2]). If it was, we overrode the value of the dir variable, dir = process.argv[2], and we then used that as the readdir argument.&#xA;If you give it a non-existent directory pathname, an error will be thrown and printed using the catch clause. That looks like so:&#xA;   $ node ls2.js /nonexistent&#xA;   { Error: ENOENT: no such file or directory, scandir '/nonexistent'&#xA;    errno: -2,&#xA;    code: 'ENOENT',&#xA;    syscall: 'scandir',&#xA;    path: '/nonexistent' }&#xA;"/>

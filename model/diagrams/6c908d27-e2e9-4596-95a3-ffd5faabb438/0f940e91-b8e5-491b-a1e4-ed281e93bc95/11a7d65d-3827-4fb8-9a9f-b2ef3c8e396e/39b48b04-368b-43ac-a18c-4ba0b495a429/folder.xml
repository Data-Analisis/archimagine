<archimate:Folder
    xmlns:archimate="http://www.archimatetool.com/archimate"
    name="Performance and utilization"
    id="39b48b04-368b-43ac-a18c-4ba0b495a429"
    documentation="Some of the excitement over Node.js is due to its throughput (the requests per second it can serve). Comparative benchmarks of similar applications, for example, Apache, show that Node.js has tremendous performance gains.&#xA;One benchmark going around is this simple HTTP server (borrowed from https://nodejs.org/en/), which simply returns a Hello World message directly from memory:&#xA;   var http = require('http');&#xA;   http.createServer(function (req, res) {&#xA;     res.writeHead(200, {'Content-Type': 'text/plain'});&#xA;     res.end('Hello World\n');&#xA;   }).listen(8124, &quot;127.0.0.1&quot;);&#xA;   console.log('Server running at http://127.0.0.1:8124/');&#xA;This is one of the simpler web servers that you can build with Node.js. The http object encapsulates the HTTP protocol, and its http.createServer method creates a whole web server, listening on the port specified in the listen method. Every request (whether a GET or POST on any URL) on that web server calls the provided function. It is very simple and lightweight. In this case, regardless of the URL, it returns a simple text/plain that is the Hello World response.&#xA;Ryan Dahl showed a simple benchmark (https:/​/​www.​youtube.​com/​watch?​v=​M- sc73Y-​zQA) that returned a 1-megabyte binary buffer; Node.js gave 822 req/sec, while Nginx gave 708 req/sec, for a 15% improvement over Nginx. He also noted that Nginx peaked at four megabytes memory, while Node.js peaked at 64 megabytes.&#xA;The key observation was that Node.js, running an interpreted JIT-compiled high-level language, was about as fast as Nginx, built of highly optimized C code, while running similar tasks. That presentation was in May 2010, and Node.js has improved hugely since then, as shown in Chris Bailey's talk that we referenced earlier.&#xA;Yahoo! search engineer Fabian Frank published a performance case study of a real- world search query suggestion widget implemented with Apache/PHP and two variants of Node.js stacks (http://www.slideshare.net/FabianFrankDe/nodejs-performance-case-study). The application is a pop-up panel showing search suggestions as the user types in phrases, using a JSON-based HTTP query. The Node.js version could handle eight times the number of requests per second with the same request latency. Fabian Frank said both Node.js stacks scaled linearly until CPU usage hit 100%. In another presentation (http://www.slideshare.net/FabianFrankDe/yahoo-scale-nodejs), he discussed how Yahoo! Axis is running on Manhattan + Mojito and the value of being able to use the same language (JavaScript) and framework (YUI/YQL) on both frontend and backend.&#xA;LinkedIn did a massive overhaul of their mobile app using Node.js for the server-side&#xA;to replace an old Ruby on Rails app. The switch let them move from 30 servers down&#xA;to three, and allowed them to merge the frontend and backend team because&#xA;everything was written in JavaScript. Before choosing Node.js, they'd evaluated Rails&#xA;with Event Machine, Python with Twisted, and Node.js, choosing Node.js for the&#xA;reasons that we just discussed. For a look at what LinkedIn did, see&#xA;http://arstechnica.com/information-technology/2012/10/a-behind-the-scenes- look-at-linkedins-mobile-engineering/.&#xA;Most existing advice on Node.js performance tips tends to have been written for older V8 versions that used the CrankShaft optimizer. The V8 team has completely dumped CrankShaft, and it has a new optimizer called TurboFan. For example, under CrankShaft, it was slower to use try/catch, let/const, generator functions, and so on. Therefore, common wisdom said to not use those features, which is depressing because we want to use the new JavaScript features because of how much it has improved the JavaScript language. Peter Marshall, an Engineer on the V8 team at Google, gave a talk at Node.js Interactive 2017 claiming that, under TurboFan, you should just write natural JavaScript. With TurboFan, the goal is for across-the-board performance improvements in V8. To view the presentation, see https:/​/​www. youtube.​com/​watch?​v=​YqOhBezMx1o.&#xA;A truism about JavaScript is that it's no good for heavy computation work, because of the nature of JavaScript. We'll go over some ideas related to this in the next section. A talk by Mikola Lysenko at Node.js Interactive 2016 went over some issues with numerical computing in JavaScript, and some possible solutions. Common numerical computing involves large numerical arrays processed by numerical algorithms that you might have learned in Calculus or Linear Algebra classes. What JavaScript lacks is multi-dimensional arrays, and access to certain CPU instructions. The solution he presented is a library to implement multi-dimensional arrays in JavaScript, along with another library full of numerical computing algorithms. To view the presentation, see https:/​/​www.​youtube.​com/​watch?​v=​1ORaKEzlnys.&#xA;The bottom line is that Node.js excels at event-driven I/O throughput. Whether a Node.js program can excel at computational programs depends on your ingenuity in working around some limitations in the JavaScript language. A big problem with computational programming is that it prevents the event loop from executing and, as we will see in the next section, that can make Node.js look like a poor candidate for anything."/>

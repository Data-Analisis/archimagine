<archimate:Folder
    xmlns:archimate="http://www.archimatetool.com/archimate"
    name="Is Node.js a cancerous scalability disaster?"
    id="5e6ad403-7720-44c5-a245-a1426e5cee8a"
    documentation="In October 2011, software developer and blogger Ted Dziuba wrote a blog post (since pulled from his blog) titled Node.js is a cancer, calling it a scalability disaster. The example he showed for proof is a CPU-bound implementation of the Fibonacci sequence algorithm. While his argument was flawed, he raised a valid point that Node.js application developers have to consider the following: where do you put the heavy computational tasks?&#xA;A key to maintaining high throughput of Node.js applications is ensuring that events are handled quickly. Because it uses a single execution thread, if that thread is bogged down with a big calculation, Node.js cannot handle events, and event throughput will suffer.&#xA;The Fibonacci sequence, serving as a stand-in for heavy computational tasks, quickly becomes computationally expensive to calculate, especially for a naiÌˆve implementation such as this:&#xA;   const fibonacci = exports.fibonacci = function(n) {&#xA;       if (n === 1 || n === 2) return 1;&#xA;       else return fibonacci(n-1) + fibonacci(n-2);&#xA;}&#xA;Yes, there are many ways to calculate fibonacci numbers more quickly. We are showing this as a general example of what happens to Node.js when event handlers are slow, and not to debate the best ways to calculate mathematics functions. Consider this server:&#xA;   const http = require('http');&#xA;   const url  = require('url');&#xA;   const fibonacci = // as above&#xA;   http.createServer(function (req, res) {&#xA;     const urlP = url.parse(req.url, true);&#xA;     let fibo;&#xA;     res.writeHead(200, {'Content-Type': 'text/plain'});&#xA;     if (urlP.query['n']) {&#xA;       fibo = fibonacci(urlP.query['n']);&#xA;       res.end('Fibonacci '+ urlP.query['n'] +'='+ fibo);&#xA;     } else {&#xA;       res.end('USAGE: http://127.0.0.1:8124?n=## where ## is the&#xA;   Fibonacci number desired');&#xA;     }&#xA;   }).listen(8124, '127.0.0.1');&#xA;   console.log('Server running at http://127.0.0.1:8124');&#xA;For sufficiently large values of n (for example, 40), the server becomes completely unresponsive because the event loop is not running, and instead this function is blocking event processing because it is grinding through the calculation.&#xA;Does this mean that Node.js is a flawed platform? No, it just means that the programmer must take care to identify code with long-running computations and develop solutions. These include rewriting the algorithm to work with the event loop, or rewriting the algorithm for efficiency, or integrating a native code library,&#xA;or foisting computationally expensive calculations on to a backend server.&#xA;A simple rewrite dispatches the computations through the event loop, letting the server continue to handle requests on the event loop. Using callbacks and closures (anonymous functions), we're able to maintain asynchronous I/O and concurrency promises:&#xA;   const fibonacciAsync = function(n, done) {&#xA;       if (n === 0) return 0;&#xA;       else if (n === 1 || n === 2) done(1);&#xA;       else if (n === 3) return 2;&#xA;       else {&#xA;           process.nextTick(function() {&#xA;               fibonacciAsync(n-1, function(val1) {&#xA;   process.nextTick(function() {&#xA;                       fibonacciAsync(n-2, function(val2) {&#xA;                       done(val1+val2); });&#xA;}); });&#xA;}); }&#xA;}&#xA;Because this is an asynchronous function, it necessitates a small refactoring of the server:&#xA;   const http = require('http');&#xA;   const url  = require('url');&#xA;const fibonacciAsync = // as above&#xA;   http.createServer(function (req, res) {&#xA;     let urlP = url.parse(req.url, true);&#xA;     res.writeHead(200, {'Content-Type': 'text/plain'});&#xA;     if (urlP.query['n']) {&#xA;       fibonacciAsync(urlP.query['n'], fibo => {&#xA;           res.end('Fibonacci '+ urlP.query['n'] +'='+ fibo);&#xA;});&#xA;     } else {&#xA;       res.end('USAGE: http://127.0.0.1:8124?n=## where ## is the&#xA;   Fibonacci number desired');&#xA;     }&#xA;   }).listen(8124, '127.0.0.1'); console.log('Server running at&#xA;   http://127.0.0.1:8124');&#xA;Dziuba's valid point wasn't expressed well in his blog post, and it was somewhat lost in the flames following that post. Namely, that while Node.js is a great platform for I/O-bound applications, it isn't a good platform for computationally intensive ones.&#xA;Later in this book, we'll explore this example a little more deeply."/>

<archimate:Folder
    xmlns:archimate="http://www.archimatetool.com/archimate"
    name="Chapter 11 - Unit Testing and Functional Testing"
    id="e8c243b6-4541-43fe-aee4-90ea48a65c61"
    documentation="Unit testing has become a primary part of good software development practice. It is a method by which individual units of source code are tested to ensure proper functioning. Each unit is theoretically the smallest testable part of an application. In a Node.js application, you might consider each module as a unit.&#xA;In unit testing, each unit is tested separately, isolating the unit under test as much as possible from other parts of the application. If a test fails, you would want it to be due to a bug in your code rather than a bug in the package that your code happens to use. A common technique is to use mock objects or mock data to isolate individual parts of the application from one another.&#xA;Functional testing, on the other hand, doesn't try to test individual components, but instead it tests the whole system. Generally speaking, unit testing is performed by the development team, and functional testing is performed by a Quality Assurance (QA) or Quality Engineering (QE) team. Both testing models are needed to fully certify an application. An analogy might be that unit testing is similar to ensuring that each word in a sentence is correctly spelled, while functional testing ensures that the paragraph containing that sentence has a good structure.&#xA;In this chapter, we'll cover:&#xA;Assertions as the basis of software tests&#xA;The Mocha unit testing framework and the Chai assertions library Using tests to find bugs and fixing the bug&#xA;Using Docker to manage test infrastructure&#xA;Testing a REST backend service&#xA;UI testing in a real web browser using Puppeteer&#xA;Improving UI testability with element ID attributes"/>

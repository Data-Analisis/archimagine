<archimate:Folder
    xmlns:archimate="http://www.archimatetool.com/archimate"
    name="Summary"
    id="f364ce7b-295c-4c8c-980b-d21612d5695b"
    documentation="This chapter has been quite a journey. We went from an application that existed solely on our laptop, to exploring two ways to deploy Node.js applications to a production server.&#xA;We started by reviewing the Notes application architecture and how that will affect deployment. That enabled you to understand what you had to do for server deployment.&#xA;Then you learned the traditional way to deploy services on Linux using an init script. PM2 is a useful tool for managing background processes in such an environment. You also learned how to provision a remote server using a virtual machine hosting service.&#xA;Then you took a long trip into the land of Docker, a new and exciting system for deploying services on machines. You learned how to write a Dockerfile so that Docker knows how to construct a service image. You learned several ways to deploy Docker images on a laptop or on a remote server. And you learned how to describe a multi-container application using Docker compose.&#xA;You're almost ready to wrap up this book. You've learned a lot along the way; there are two final things to cover.&#xA;In the next chapter, we will learn about both unit testing and functional testing. While a core principle of test-driven development is to write the unit tests before writing the application, we've done it the other way around and put the chapter about unit testing at the end of this book. That's not to say unit testing is unimportant, because it is extremely important.&#xA;In the final chapter, we'll explore how to harden our application, and application infrastructure, against attackers."/>

<archimate:Folder
    xmlns:archimate="http://www.archimatetool.com/archimate"
    name="Hybrid CommonJS/Node.js/ES6 module scenarios"
    id="2e48b3dc-9577-4cc2-b220-588fb527bb82"
    documentation="We've gone over the format for CommonJS/Node.js modules, the format for ES6 modules, and the algorithm for locating and importing both. The last thing to cover is those hybrid situations where our code will use both module formats at the same time.&#xA;As a practical matter, ES6 modules are very new to the Node.js platform, and therefore we have a large body of existing code written as CommonJS/Node.js modules. Many tools in the Node.js market have implementation dependencies on the CommonJS format. This means we'll be facing situations where ES6 modules will need to use CommonJS modules, and vice versa:&#xA;CommonJS module loads other CommonJS modules with require()&#xA;CommonJS module cannot load ES6 modulesâ€”except for two methods: Dynamic import, also known as import(), can load an ES6 module as an asynchronous operation&#xA;The @std/esm package supplies a require() function with one that can load ES6 modules as an asynchronous operation&#xA;ES6 modules load other ES6 modules with import, with the full semantics of the import statement&#xA;ES6 modules load CommonJS modules using import&#xA;Therefore, out of the box, three of the scenarios are directly supported. The fourth is&#xA;supported with a workaround module.&#xA;When an ES6 module loads a CommonJS module, its module.exports object is exposed as the default export of the module. This means your code uses this pattern:&#xA;   import cjsModule from 'common-js-module';&#xA;   ...&#xA;   cjsModule.functionName();&#xA;This is extremely similar to using a CommonJS module in another CommonJS module. You are simply transliterating the require() call into an import statement.&#xA;"/>

<archimate:Folder
    xmlns:archimate="http://www.archimatetool.com/archimate"
    name="Dynamic imports with import() "
    id="74da31b1-410a-4fee-a5b4-8aa8f6fadd12"
    documentation="ES6 modules do not cover all the requirements to fully replace Node.js/CommonJS modules. One of the missing capabilities is being addressed with the Dynamic Import feature currently on its way through the TC-39 committee.&#xA;Support for dynamic imports landed in Node.js 9.7. See the documentation at: https:/​/​github.​com/​tc39/​proposal-​dynamic-​import.&#xA;We'll use dynamic imports to solve an issue in Chapter 7, Data Storage and Retrieval, about dynamically choosing the module to load. In normal usage of the require() statement, can use a simple string literal to specify the module name. But it is also possible to use a string literal to compute the module name, like so:&#xA;   // Node.js dynamically determined module loading&#xA;   const moduleName = require(`../models/${process.env.MODEL_NAME}`);&#xA;We used this technique in earlier editions of this book to dynamically choose between several implementations of the same model API. The ES6 import statement does not support anything but a simple string literal, and therefore cannot compute the module specifier like this example.&#xA;With dynamic imports, we have an import() function where the module specifier is a regular string, letting us make a similar dynamic choice of module. Unlike the require() function, which is synchronous, import() is asynchronous, and returns a Promise. Hence, it's not a direct replacement for require() in that it's not terribly useful as a top-level function. You'll see how to use it in Chapter 7, Data Storage and Retrieval.&#xA;Perhaps the most important feature it brings is that CommonJS modules can use import() to load an ES6 module.&#xA;"/>

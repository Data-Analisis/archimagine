<archimate:Folder
    xmlns:archimate="http://www.archimatetool.com/archimate"
    name="Demonstrating module-level encapsulation"
    id="cc7599eb-e407-4af2-bef2-ce3512108c5b"
    documentation="A key attribute of modules is encapsulation. The objects that are not exported from the module are private to the module, and cannot be accessed from code outside the module. To reiterate, modules are treated as if they were written as follows:&#xA;   (function() { ... contents of module file ... })();&#xA;This JavaScript idiom defines an anonymous private scope. Anything declared within that scope cannot be accessed by code outside the scope. That is, unless some code makes object references available to other code outside this private scope. That's what the module.exports object does: it is a mechanism for the module author to expose object references from the module. Other code can then access resources inside the module in a controlled fashion.&#xA;The top-level variables inside a module look like they exist in the global scope. Instead of being truly Global, they're safely private to the module and are completely inaccessible to other code.&#xA;Let's take a look at a practical demonstration of that encapsulation. Create a file named module1.js, containing the following:&#xA;   const A = &quot;value A&quot;;&#xA;   const B = &quot;value B&quot;;&#xA;   exports.values = function() {&#xA;      return { A: A, B: B };&#xA;   }&#xA;Then, create a file named module2.js, containing the following:&#xA;   const util = require('util');&#xA;   const A = &quot;a different value A&quot;;&#xA;   const B = &quot;a different value B&quot;;&#xA;   const m1 = require('./module1');&#xA;   console.log(`A=${A} B=${B} values=${util.inspect(m1.values())}`);&#xA;   console.log(`${m1.A} ${m1.B}`);&#xA;   const vals = m1.values();&#xA;   vals.B = &quot;something completely different&quot;;&#xA;   console.log(util.inspect(vals));&#xA;   console.log(util.inspect(m1.values()));&#xA;Then, run it as follows (you must have Node.js already installed):&#xA;   $ node module2.js&#xA;   A=a different value A B=a different value B values={ A: 'value A', B:&#xA;   'value B' }&#xA;   undefined undefined&#xA;   { A: 'value A', B: 'something completely different' }&#xA;   { A: 'value A', B: 'value B' }&#xA;This artificial example demonstrates encapsulation of the values in module1.js from those in module2.js. The A and B values in module1.js don't overwrite A and B&#xA;in module2.js because they're encapsulated within module1.js. The&#xA;values function in module1.js does allow code in module2.js access to the values; however, module2.js cannot directly access those values. We can modify the object module2.js received from module1.js. But doing so does not change the values within module1.js."/>

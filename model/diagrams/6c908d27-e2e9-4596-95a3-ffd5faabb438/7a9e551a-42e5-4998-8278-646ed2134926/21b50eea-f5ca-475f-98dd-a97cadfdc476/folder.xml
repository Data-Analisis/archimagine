<archimate:Folder
    xmlns:archimate="http://www.archimatetool.com/archimate"
    name="Defining a module"
    id="21b50eea-f5ca-475f-98dd-a97cadfdc476"
    documentation="Modules are the basic building blocks for constructing Node.js applications. A Node.js module encapsulates functions, hiding details inside a well-protected container, and exposing an explicitly-declared list of functions.&#xA;There are two module formats that we must consider:&#xA;The traditional Node.js format based on the CommonJS standard has been used since Node.js was created.&#xA;With ES2015/2016 a new format, ES6 Modules, has been defined with a new import keyword. ES6 modules will be (or is) supported in all JavaScript implementations.&#xA;Because ES6 modules are now the standard module format, the Node.js Technical Steering Committee (TSC) is committed to first-class support for ES6 modules.&#xA;We have already seen modules in action in the previous chapter. Every JavaScript file we use in Node.js is itself a module. It's time to see what they are and how they work. We'll start with CommonJS modules and then quickly bring in ES6 modules.&#xA;In the ls.js example in Chapter 2, Setting up Node.js, we wrote the following code to pull in the fs module, giving us access to its functions:&#xA;   const fs = require('fs');&#xA;The require function searches for the named module, loading the module definition into the Node.js runtime, and making its functions available. In this case, the fs object contains the code (and data) exported by the fs module. The fs module is part of the Node.js core and provides filesystem functions.&#xA;By declaring fs as const, we have a little bit of assurance against making coding mistakes that would modify the object holding the module reference.&#xA;In every Node.js module, the exports object within the module is the interface exported to other code. Anything assigned to a field of the exports object is available to other pieces of code, and everything else is hidden. By the way, this object is actually module.exports. The exports object is an alias for module.exports.&#xA;The require function and module.exports objects both come from the CommonJS specification. ES6 modules have similar concepts, but a different implementation.&#xA;Let's look at a brief example of this before diving into the details. Ponder over the simple.js module:&#xA;   var count = 0;&#xA;   exports.next = function() { return ++count; };&#xA;   exports.hello = function() {&#xA;     return &quot;Hello, world!&quot;;&#xA;   };&#xA;We have one variable, count, which is not attached to the exports object, and a function, next, which is attached. Now, let's use it:&#xA;   $ node&#xA;   > const s = require('./simple');&#xA;   undefined&#xA;   > s.hello();&#xA;   'Hello, world!'&#xA;> s.next();&#xA;   1&#xA;   > s.next();&#xA;   2&#xA;   > s.next();&#xA;   3&#xA;   > console.log(s.count);&#xA;   undefined&#xA;   undefined&#xA;   >&#xA;The exports object in the module is the object that is returned by require('./simple'). Therefore, each call to s.next calls the next function in simple.js. Each returns (and increments) the value of the local variable, count. An attempt to access the private field, count, shows it's unavailable from outside the module.&#xA;To reiterate the rule:&#xA;Anything (functions or objects) assigned as a field of exports (as known&#xA;as module.exports) is available to other code outside the module Objects not assigned to exports are not available to code outside the&#xA;module, unless the module exports those objects via another mechanism&#xA;This is how Node.js solves the global object problem of browser-based JavaScript. The variables that look like they're global variables are only global to the module containing that variable. These variables are not visible to any other code.&#xA;Now that we've got a taste for modules, let's take a deeper look."/>
